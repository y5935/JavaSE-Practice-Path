# DataType, Operator and Control Flow
<!-- MarkdownTOC -->

- [1. Java 的命名规范是什么?](#1-java-%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%98%AF%E4%BB%80%E4%B9%88)
- [2. 分析 Unicode 编码，并应用](#2-%E5%88%86%E6%9E%90-unicode-%E7%BC%96%E7%A0%81%EF%BC%8C%E5%B9%B6%E5%BA%94%E7%94%A8)
- [3. error: duplicate local variable a](#3-error-duplicate-local-variable-a)
- [4. 二进制与 Java 的位运算](#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E-java-%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97)
- [5.](#5)

<!-- /MarkdownTOC -->


<a name="1-java-%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%98%AF%E4%BB%80%E4%B9%88"></a>
## 1. Java 的命名规范是什么?
> 在日常开发中, 规范对于团队协同开发, 后期代码的维护非常的重要. 不仅是命名规范, 还有其他方面, 如: 代码格式等, 都是需要统一规范的.

- [Sun: Code Conventions for the Java Programming Language](http://blog.csdn.net/thl789/article/details/8025273)

- [阿里 Java 使用规范](https://github.com/ForrestLyu/JavaSE-Practice-Path/blob/master/Notes/resource/ali_java.pdf)


<a name="2-%E5%88%86%E6%9E%90-unicode-%E7%BC%96%E7%A0%81%EF%BC%8C%E5%B9%B6%E5%BA%94%E7%94%A8"></a>
## 2. 分析 Unicode 编码，并应用 

> Java 中码点和代码单元

在 Java 中，char 类型描述了 UTF-16 中的一个代码单元，不足以描述所有的字符。**不推荐在程序中使用 char 类型！**

Java 字符串是由 char 值序列组成, 而 char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元; 大多数常用的 Unicode 字符使用一个代码单元, 但是辅助字符(复杂字符)需要使用一对代码单元.

**总结: 一个码点代表一个字符; 简单字符(大部分)只需要一个代码单元, 极少部分字符需要两个代码单元.**

```java
/*
 1. 返回代码单元长度, 码点长度
*/
// length() 返回的是采用 UTF-16 编码表示的给定字符串所需要的代码单元数量
// 请注意, 有个字符是由 2 个代码单元组成, 这就是说 length 无法表示具体的字符数量
String greeting = "Hello";
greeting.length();  // is 5

// 可以通过 codePointCount() 方法, 返回实际的码点数量(即, 字符数量)
greeting.codePointCount(0, greeting.length());

/*
 2.返回索引值位 i 的代码单元, 码点值
*/
// 代码单元
char first = greeting.charAt(0);
char last = greeting.charAt(greeting.length()-1);

// 码点值
int index = greeting.offsetByCodePoints(0, i);
int cp = greeting.codePointAt(index);

/*
 3. 一个问题实例:
 考虑如下字符序列: 
 Stirng sentence = "𝕆 is th set of octonions"
*/

char ch = sentence.charAt(1); // 返回的不是空格, 而是 𝕆 的第 2 个代码单元

// 为了避免这样的问题, 请尽量不要使用 char 类型

```

**总结: 因为 Java 使用的是 Unicode 字符集, 存在 "复杂字符需要两个代码单元存储" 的问题, 所以在源程序中, 尽量不要使用 char 类型, 应当使用 String 类型**

```java
/*
 码点可以与 String 进行相互的转换;
*/

// 遍历一个字符串, 查看每一个码点
int[] codePoints = sentence.codePoints().toArray();

// 将 码点数组 转换成 String 类型
String str = new String(codePoints, 0 , codePoints.length);
```


<a name="3-error-duplicate-local-variable-a"></a>
## 3. error: duplicate local variable a

不能在 inner block 中定义同名的变量

```java
int a = 21;
{
//  int a = 21; error: duplicate local variable a
}
for(int i=0; i<100; ++i) {
//  int a = 21; error
}
```


<a name="4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E-java-%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97"></a>
## 4. 二进制与 Java 的位运算

```java
int a = 2_100_000_000;  // JDK 1.7 引入下划线，很方便吧 :-D
//同时加入了 0b 表示
```

在开始之前：
- 二进制的由来？
- Java 为什么由位运算？更高效吗？

1. Binary system

莱布尼茨的论文。计算机中通过晶体管的高低电流表示 0 和 1：降低硬件复杂度；

在程序中，通过原码表示正数；补码表示负数。（符号位不动，其余为取反，再 + 1）

特例：byte 类型中: 

`1000_0000` 表示 -128

2. Java 为什么使用位运算？

当某些嵌入式设备，只支持移位运算的时候。

Bitwise Operators:
- `&`, 用于位清零；取一个数的指定位；
- `|`，用于位设置1；
- `^`，用于位翻转；
- `~`
- `>>`, 最高位 0，就补 0；最高位位 1，就补 1；
- `>>>`, 请参考 >> 规则。不需要考虑最高位，直接补 0；
- `<<`, 溢出，就直接丢弃掉；


<a name="5"></a>
## 5. 

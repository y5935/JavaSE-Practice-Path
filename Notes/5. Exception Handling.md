# Exception Handling
> 异常处理, 是 Java 的一种健壮机制, 用于处理正常运行程序可能出现的意外情况. 
> 
> 异常处理提供了一种将正常代码和错误处理代码分开的有效方式; 

## 1. 基础概念
1.1 健壮的程序, 应当做到: 
- 向用户通报错误;
- 保存所有工作的结果;
- 允许用户用妥善的形式退出程序;

1.2 异常处理的任务: 

异常处理的任务就是将控制权从错误产生的地方转移到能够处理这种情况的 Exception Handler (异常处理器).

1.3 异常处理机制运行流程:

当 Java 程序中, 方法 A 发生异常无法完成它的任务时, 就需要 throw (抛出) 一个封装了错误信息的对象; 注意: 方法 A 不会返回任何值, 就会立即退出, 调用方法 A 的方法也无法继续执行; 取而代之的是, 异常处理机制开始搜寻能够处理这种异常情况的 Exception Handler (异常处理器).

1.4 JavaSE 8 API: 
ParseException
```
public class Throwable
extends Object
implements Serializable

1.  
The Throwable class is the superclass of all errors and exceptions in the Java language. Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement. 
Throwable 类是所有 errors 和 exceptions 的基类, 只有 Throwable 及其子类的对象实例才能够被 JVM 或者 throw 子句 throw(抛出).

2. 
Similarly, only this class or one of its subclasses can be the argument type in a catch clause. For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.
类似地, Throwable 及其子类的对象实例可以作为 catch 子句的参数. ??? (编译时检查的内容)

3. 
Instances of two subclasses, Error and Exception, are conventionally(通常地) used to indicate that exceptional situations have occurred. Typically, these instances are freshly created in the context of the exceptional situation so as to include relevant information (such as stack trace data).

4. 
A throwable contains a snapshot of the execution stack of its thread at the time it was created. (异常中包含线程运行栈中的信息). It can also contain a message string that gives more information about the error. Over time, a throwable can suppress other throwables from being propagated(激发). Finally, the throwable can also contain a cause: another throwable that caused this throwable to be constructed. The recording of this causal information is referred to as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a "chain" of exceptions, each caused by another. (异常链)

5. 
One reason that a throwable may have a cause is that the class that throws it is built atop a lower layered abstraction, and an operation on the upper layer fails due to a failure in the lower layer. It would be bad design to let the throwable thrown by the lower layer propagate outward, as it is generally unrelated to the abstraction provided by the upper layer. Further, doing so would tie the API of the upper layer to the details of its implementation, assuming the lower layer's exception was a checked exception. Throwing a "wrapped exception" (i.e., an exception containing a cause) allows the upper layer to communicate the details of the failure to its caller without incurring either of these shortcomings. It preserves the flexibility to change the implementation of the upper layer without changing its API (in particular, the set of exceptions thrown by its methods).

6. 
A second reason that a throwable may have a cause is that the method that throws it must conform to a general-purpose interface that does not permit the method to throw the cause directly. For example, suppose a persistent collection conforms to the Collection interface, and that its persistence is implemented atop java.io. Suppose the internals of the add method can throw an IOException. The implementation can communicate the details of the IOException to its caller while conforming to the Collection interface by wrapping the IOException in an appropriate unchecked exception. (The specification for the persistent collection should indicate that it is capable of throwing such exceptions.)

7. 
A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the initCause(Throwable) method. New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the Throwable constructors that takes a cause. Because the initCause method is public, it allows a cause to be associated with any throwable, even a "legacy throwable" whose implementation predates the addition of the exception chaining mechanism to Throwable.

9. 
By convention, class Throwable and its subclasses have two constructors, one that takes no arguments and one that takes a String argument that can be used to produce a detail message. Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a Throwable (the cause), and one that takes a String (the detail message) and a Throwable (the cause).


```


## 2. Exception (异常)

### 2.1 The hierarchy (异常继承体系)


所有异常都是由 Throwable 类继承而来, 在下一层分成了两个分支: Error 和 Exception.

Error 类层次结构描述了 Java 程序运行中内部错误和资源耗尽错误. **应用程序不应该 throw 此类错误**. 如果出现此类错误, 应当: 告知用户错误信息, 并尽量安全退出程序.

Exception 类层次结构又分为了: **RuntimeException 和 其他异常**; 其中, 由程序错误导致的异常属于 **RuntimeException**; 而程序本身没有问题, 但是由于 IO 错误这类问题导致的异常, 属于 **其他异常**
1. 派生于 RuntimeException 的异常包含下面几种情况:
    - ClassCastException
    - IndexOutOfBoundsException
    - NullPointerException
    - ArithmeticException (For Example, an integer "divide by zero")

2. 不是派生于 RuntimeException 的异常: 
    - IOException (如, FileNotFoundException)
    - ??
    - ??

**Java 语言规范中, 将派生于 Error 类和 RuntimeException 类的所有异常成为 unchecked (非受查异常), 所有其他异常成为 check (受查) 异常.  
 编译器将会检查, 是否为所有 check 异常, 提供 Exception Handler.
**

### 2.2 声明 Check Exception
```java
// 受查异常, 举例
// FileInputStream constructor
public FileInputStream(String name) throws FileNotFoundException

```


在自己编写方法的时候, 不必将所有可能抛出的异常都进行声明. 什么时候需要, 哪些异常需要, 遵循以下规则:  
1. 调用一个 **抛出 checked exception 方法**, 如: FileInputStream();
2. 程序运行中, 发现错误, 并用 throw 子句抛出 Exception 时;
3. 程序出现错误时, 如: a[-1] = 0, 会 throw 一个 ArrayIndexOutOfBoundsException 异常;
4.  Java 的 JVM 和 Runtime Library 出现 internal Error;

**但是不需要声明 Java 的 Error, 任何程序代码都具有抛出此类异常的可能性, 但是我们无能为力

同时, 也不需要声明从 RuntimeException 继承的那些 uncheck exception, 这是在编写程序的时候, 可以避免的.**

```java
// 假设在读取文件信息的时候, 遇到异常结束的情况
String readData() throws IOException {
    //...

    while(operational conditon) {
        if(!in.hasNext()) {  // EOF
            //....


            if (n < fileLength) {
                String msg = "文件没有读完, 就终止啦!"
                throw new EOFException(msg);
            }
        }
    }
}


```


有时候, 现有的异常类, 无法准确的描述问题, 这个时候, 就可以自定义异常类.

```java
class CustomException extends EOFException {
    // 应当定义 2 个构造方法
    public CustomException() {}

    public CustomException(String msg) {
        super(msg);
    }
}

```

### 2.3 除了声明异常, 还可以捕获异常
> 声明异常, 会使异常抛出方法之外; 捕获异常, 可以在当前方法中处理.

```java
try {
    // code that might throw exceptions
} catch (FileNotFoundException | UnknownHostException e) {
    // emergency action for missing files and unknown hosts
} catch (IOException e) {
    // emergency action for all other IO exception
} catch (Exception e) {
    // emergency action for all Exception
} Finally {
    // Finally, 
}
```

但是, 应该解耦 try/catch 和 try/finally 语句块, 这样可以提高代码的清晰度

```java
InputStram is = ....;
try {
    try {
            // code that might throw exceptions
        } finally {
            is.close();
        }
} catch (IOException e) {
    // show error message;
}

/*
 解析:
 1. 内层的 try/finally 语句块, 只有一个职责, 确保关闭 input stram;
 2. 外层的 try/catch 语句块, 只有一个职责, 确保报告出现的错误, 此外, 还可以报告 finally 子句中的错误
*/
```




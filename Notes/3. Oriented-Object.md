# Object-Oritened

## 1. Process-Oritened VS Object-Oritened

PO: 关注算法

OO: 关注数据


### 1.1 OOP 注意点(封装的设计技巧)

- field: 
    + 一定要保证是: private
    + 一定要 initialize field
    + 不要再类中使用过多的 primitive type

    ```
    // 不应该这样
    private String country;
    private String city;
    private String postcode;

    // 应该直接使用 class Address 存储
    ```

    + 不是所有的 field 都需要 access method 和 mutator method
- 将职责过多的类进行分解, 并且保证名如其职; (Class/Field 用 noun; Method 用 verb.)
- 优先使用 immutable class. (如, String / LocalDate)

### 1.2 继承的设计技巧

- 将公共操作和域放在超类;
- 不要使用 protected field;
- 使用继承实现 "is-a" 关系, 而且保证继承是有意义的;
- 在 override super class method 时, 不要改变预期的行为;
- 使用多态, 而非类型信息;
- 不要过多的使用 Reflection 机制;



## 2. Encapsulation / Inheritance / Polymorphism / Reflection

```java
package com.devlyu.pl.oo;

import java.time.LocalDate;

public class Employee {
    private String name;
    private double salary;
    private LocalDate hireDate;
    
    /*
     * if the constructor 'Employee()' is not defined, it would occure problem: 
     * Implicit super constructor Employee() is undefined for default constructor. 
     * Must define an explicit constructor
     */
    public Employee() {
        init("", 0.0, null);
    }
    
    
    public Employee(String name, double salary, LocalDate hireDate) {
        init(name, salary, hireDate);
    }
    
    private void init(String name, double salary, LocalDate hireDate) {
        this.name = name;
        this.salary = salary;
        this.hireDate = hireDate;
    }


    /*
     * setter / getter
     */
    public String getName() {
        return name;
    }


    public void setName(String name) {
        this.name = name;
    }


    public double getSalary() {
        return salary;
    }


    public void setSalary(double salary) {
        this.salary = salary;
    }


    public LocalDate getHireDate() {
        return hireDate;
    } 
}
```

```java
package com.devlyu.pl.oo;

import java.time.LocalDate;

public class Manager extends Employee{
    private double bonus;
    
    public Manager() {
        super();
    }
    
    public Manager(String name, double salary, LocalDate hireDate, double bonus) {
        super(name, salary, hireDate);
        
        this.bonus = bonus;
    }

    public double getBonus() {
        return bonus;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }
    
    public double getSalary() {
//      return getSalary() + bonus;  这里是典型的错误
        return super.getSalary() + bonus;
    }
}
```

**总结:**  
- super class: 
    + 必须将 field 设置为 private, 并提供必要的 setter / getter 方法(并不是所有 field 都需要);  
    + 如果需要作为 super class, 必须提供 ClassName() 构造器;

- derived class:  
    + 无法访问 super class 中 private field, 应该使用 access method;
    + this 指代当前的 instance 的引用, 可以赋值给 该对象实例; 但是 super 不是父类一个对象的引用, super 只是一个指示编译器调用 super class 方法的特殊 keyword;
    + derived class 可以增加, 覆盖 super class field / method, 但是无法删除哦;


### 2.1 this 和 super 深入理解

关键字 this 有 2 个作用: 
- 引用 implicit 参数;
- 调用该类的其他构造器;

**this 是当前类实例的引用, 可以进行赋值操作;**

关键字 super 有 2 个作用:  
- 调用 super class method / field(一般只能访问非 private 修饰的; 很少有这种情况)
- 调用 super class constructor;

**super 仅仅是一个关键字, 指示编译器需要到 super class 中调用方法/构造器;**


### 2.2 Polymorphism 和 Dynamic Binding

 Polymorphism: 一个对象变量可以指示多种实际类型的现象;   
 Dynamic Binding: 该对象变量在运行过程中, 能够自动选择调用对应的方法;

 ```java
Employee boss = new Manager(...);
boss.getSalary; // 此时, 调用的是 Manager 类的 getSalary() 方法
 ```

### 2.3 Access Modifier (访问控制修饰符)

#### 2.3.1 修饰 class / emum
- public: 
- (没有修饰符): 


#### 2.3.2 修饰 field / method / constrctor 
- private: 推荐将所有的 field 修饰成 private 
- (没有修饰符): 本包, 不推荐使用; 
- protected: 本包和子类, 将需要被重写的方法, 修饰成 protected
- public: 

#### 2.3.3 修饰 inner class

### 2.4 Reflection (反射)

反射库(Reflection Library) 提供了一个工具集, 用于编写能够动态操纵 Java 代码的程序; 具有可以在设计和运行中添加新类时, 快速地应用开发工具动态地查询新添加类的能力;


能够分析类能力的程序称为反射 (Reflective):   
- 在运行时分析类的能力;
- 在运行时查看对象; 例如: 编写一个 toString() 方法供所有类使用;
- 实现通用的数组操作代码;
- 利用 Method 对象;



## 3. Interface / Lambda Expression / Inner Class / Proxy

### 3.1 Cloneable 接口, Comparable 接口
若希望, 类具有复制和比较的功能, 则应该实现 Cloneable, Comparable 接口
 


















## 4. 注意点

### 4.1 使用 UML 描述 the relationship among classes
在类中常见的 3 种关系: 
- Dependency (依赖), uses-a
- Aggregation (聚合), has-a (关联, 是另一种称呼, 而且对应的 UML 图标也不一样)
- Inheritance (继承), is-a

例: 在 **订单处理系统中**, 有: Item(商品), Order(订单), Shipping(送货地址), Payment(付款), Account(账户).

**todo-UML: class diagram**


### 4.2 深复制和浅复制

### 4.3  Override 和 Overload

Overload (重载): 针对多个同名方法, 实现不同的行为    
- 形参列表必须不同; 
- 方法名必须相同;
- 返回值, Access Modifier 没有要求;  

Override (重写): 子类对于父类方法实现的覆盖  
- 形参列表, 方法名必须相同;
- 返回值类型: 基本类型必须相同; 引用类型, 必须是父类或子类
- Access Modifier 不小于父类;
- Throw Exception 不大于父类;


### 4.4 javadoc utility  

javadoc 将从如下部分提取信息:  
- package
- public class, public interface
- public and protected constructors & methods
- public and protected fields

格式: <em>强调</em>>, <strong>着重强调</strong>, {@code 等宽代码};

### 4.5 解析 Object: 所有 class 的超类

#### 4.5.1 重写 equals() 方法

```java

    @Override
    public boolean equals(Object obj) {
        // 1. a quick test to see if the objects are identical
        if (this == obj)    return true;
        // 2. must return false if the explicit parameter is null
        if (obj == null)    return false;
        
        // 3. if the type of the class don't match, they can't be equal.
        if (this.getClass() != obj.getClass()) return false;
        // now, we know otherObject is a non-null Employee
        Employee other = (Employee) obj;
        // 4. test whether the fields have identical values
        
        /*
         * 虽然此处可以直接使用, other.name 这样直接获取 name 值, 但是我依然不推荐使用.
         */
        if (Objects.equals(this.name, other.name)
                && (Math.abs(this.salary-other.salary) < 1e-4)
                && Objects.equals(this.hireDate, other.hireDate)) {
            return true;
        }
        
        return false;
    }

```


```java
@Override
public boolean equals(Object obj) {
    // 1. a quick test to see if the objects are identical
    if (this == obj) return true;
    
    // 2. must return false if the explicit param is null
    if (obj == null) return false;
    
    // 3. if the type of the classes, they can't be equal
    if (this.getClass() != obj.getClass()) return false;
    
    // 3.1 now, we know the obj is a non-null Employee
    Employee other = (Employee) obj;
    
    // 4. test whether the fields have identical value
    // Math.abs() 细节决定成败
    if (Objects.equals(this.getName(), other.getName())
            && (Math.abs(this.getSalary()-other.getSalary()) < 1e-4)
            && Objects.equals(this.getHireDate(), other.getHireDate())) {
        return true;
    }
    
    return false;
}
```

JLS: 要求 equals() 方法:  
- 自反性: 对于任何非空引用 x, x.equals(x) 都应该返回 true
- 对称性: 对于任何非空引用 x 和 y, x.equals(y) 和 y.equals(x) 的返回结果是一样的
- 传递性: x -> y -> z
- 一致性: 如果 x 和 y 的对象没有变化, 则, equals() 返回结果也是不变的;
- 对于任意的非空引用 x, x.equals(null), 一定返回 false;

**getClass() 与 instanceof 在 equals 方法中的使用: **

- 如果子类能够拥有自己的相等的概念, 则根据对称性要求强制采用 getClass;
- 如果超类决定相等的概念(即, 超类定义了 final equals() 方法), 则可以使用 instanceof 进行检测, 这样就可以在不同的子类当中, 进行检测;


#### 4.5.2 重写 hashCode() 方法

**请看第 6 份笔记中, hash 那一部分**

#### 4.5.3 重写 toString() 方法

**用于自定义输出**






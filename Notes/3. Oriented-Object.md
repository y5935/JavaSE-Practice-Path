# Oriented-Object

<!-- MarkdownTOC -->

- [1. 分析 Oriented-Object 和 Process-Oriented](#1-%E5%88%86%E6%9E%90-oriented-object-%E5%92%8C-process-oriented)
    - [1.1 History](#11-history)
    - [1.2 OO 总结](#12-oo-%E6%80%BB%E7%BB%93)
- [2. OOD by UML](#2-ood-by-uml)
    - [2.1 Class Diagram](#21-class-diagram)
        - [2.1.1 类之间的关系](#211-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB)
    - [2.2 UseCase Diagram](#22-usecase-diagram)
    - [2.3 Sequence Diagram](#23-sequence-diagram)
- [3. 分析 Overload 和 Override](#3-%E5%88%86%E6%9E%90-overload-%E5%92%8C-override)
    - [3.1 Method Signature](#31-method-signature)
    - [3.2 Override](#32-override)
    - [3.3 Overload](#33-overload)
- [4. 分析 Access Visibility](#4-%E5%88%86%E6%9E%90-access-visibility)
    - [4.1 类](#41-%E7%B1%BB)
    - [4.2 类中 field 和 method](#42-%E7%B1%BB%E4%B8%AD-field-%E5%92%8C-method)
- [5. 封装与继承的思考](#5-%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%9D%E8%80%83)
- [6. Inheritance hierarchy](#6-inheritance-hierarchy)
- [7. 分析 Object methods](#7-%E5%88%86%E6%9E%90-object-methods)
    - [7.1 equals\(\)](#71-equals)
    - [7.2 hash value, hash table 和 hashCode\(\)](#72-hash-value-hash-table-%E5%92%8C-hashcode)
    - [7.3 toString\(\)](#73-tostring)
- [8. Reflection](#8-reflection)
- [9. Proxy](#9-proxy)

<!-- /MarkdownTOC -->

<a name="1-%E5%88%86%E6%9E%90-oriented-object-%E5%92%8C-process-oriented"></a>
## 1. 分析 Oriented-Object 和 Process-Oriented

<a name="11-history"></a>
### 1.1 History

20 世纪 70 年代中期, 以 C 语言为代表的面向过程的程序语言已经大面积应用, 此时软件开发以 "算法+数据结构=程序" 的思想进行设计, 与此同时, 操作系统, 编译器, 数据库软件开始发展.


20 世纪 90 年代, Java 的出现降低了 C++ 的复杂度, 面向对象编程开始大面积应用, 此时软件开发以 "对象+通讯=应用" 的思想进行设计与开发, 尤其是在企业级开发中.

更多: 
面向 ** 语言：面向 WEB，面向高并发，面向切面，函数式语言，面向终端开发等编程思想和语言, 只是对现有程序设计语言的改进，并为解决特定领域, 特定问题而有的.


<a name="12-oo-%E6%80%BB%E7%BB%93"></a>
### 1.2 OO 总结

OO 核心思想 ：封装，继承，多态。

相较于 PO:  
- 封装: 去掉全局变量
- 继承: 去掉代码冗余
- 多态: 为了让继承得以实现

综上: OO 优点: 1. 去全局变量; 2. 去代码冗余;

<a name="2-ood-by-uml"></a>
## 2. OOD by UML
UML (Unified Modeling Language), 是一个支持模型化和软件系统开发的图形化语言; 为软件开发的所有阶段提供模型化和可视化的支持.

<a name="21-class-diagram"></a>
### 2.1 Class Diagram
定义系统中的类结构, 以及类之间的关系.

<a name="211-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"></a>
#### 2.1.1 类之间的关系

- Denpendency (uses-a), 一个类的方法操纵另一个类的对象, 则这个类依赖另一个类;
- Aggregation (has-a), 类 A 的 instance field 中, 包含类 B;
- Inheritance (is-a), 

![class diagram](./resource/OrderSys.png)
<a name="22-usecase-diagram"></a>
### 2.2 UseCase Diagram
用例图能够以可视化的方式, 表达系统如何满足所收集的业务规则, 以及特定用户需求信息.

![usecase diagram](./resource/Restaurant.png)

<a name="23-sequence-diagram"></a>
### 2.3 Sequence Diagram
顺序图用于按照交互发生的一系列顺序, 显示对象之间的交互

![sequence diagram](./resource/Bank.png)


<a name="3-%E5%88%86%E6%9E%90-overload-%E5%92%8C-override"></a>
## 3. 分析 Overload 和 Override

<a name="31-method-signature"></a>
### 3.1 Method Signature
`method_name(param1, param2, ...)` 就是 method signature.

<a name="32-override"></a>
### 3.2 Override

当子类继承父类, 父类的方法不满足子类行为要求的时候, 子类就需要 Override 父类方法. 要求: 

- signature 不变;
- 返回值:
    + 若为 primitive type, 则必须相同;
    + 若为 reference type, 则必须相同或子类;
-  Access Modifier 不小于父类被覆盖方法;
-  抛出的异常范围不大于父类被覆盖的方法;


<a name="33-overload"></a>
### 3.3 Overload

当类中某个行为需要多种表现形式, 如乘法中, 需要有整数乘法和浮点数乘法, 此时就需要 Overload 方法, 要求: 

- signature 中, 形参列表必须不同
- 返回值类型, Access Modifier, 抛出异常范围没有要求;

<a name="4-%E5%88%86%E6%9E%90-access-visibility"></a>
## 4. 分析 Access Visibility

<a name="41-%E7%B1%BB"></a>
### 4.1 类

没有 public 修饰的类, 在不同的包中, 无法访问.

<a name="42-%E7%B1%BB%E4%B8%AD-field-%E5%92%8C-method"></a>
### 4.2 类中 field 和 method

- public > protected > (默认不写) > private
- Instance Inner Class 具有类中成员相同的访问控制修饰符

<a name="5-%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%9D%E8%80%83"></a>
## 5. 封装与继承的思考

Encapsulation:  
- 保证数据私有;
- 保证数据初始化;
- field 不要使用过多的 primitive type;
- 只提供需要的 accessor and mutator method;
- 分解职责过多的类;
- 见名知意;
- 优先使用 immutable class (确保线程安全);
from *Java 核心技术卷 1, 4.10*

Inheritance and Polymorphism:
- 将公共的操作和域放在父类;
- 不要使用 protected 修饰域; 应该使用 protected 修饰希望被子类重写的 method;
- 除非继承符合 'is-a', 并有意义, 才用继承; (如: Employee - Contractor, Calendar - Hoilday)
- 在覆盖方法时, 不要改变预期的行为;
- 使用多态代替类型信息;
- 不要过多的使用反射;

<a name="6-inheritance-hierarchy"></a>
## 6. Inheritance hierarchy

1. `java.lang`
Provides classes that are fundamental to the design of the Java programming language.

- String, StringBuffer, StringBuilder
- unchecked excepiton:
    + Error
    + RuntimeException
        * ClassCastException, IllegalArgumentException,  IndexOutOfBoundsException, NullPointerException;
    
- checked excepiton: 
    + CloneNotSupportedException, DataFormatException,  ExecutionException, IllegalClassFormatException, InterruptedException, IOException, LambdaConversionException, NamingException,  ParseException, SAXException, ScriptException, SQLException, TimeoutException

2. `java.util`
Contains the collections framework, legacy collection classes, event model, date and time facilities, internationalization, and miscellaneous utility classes (a string tokenizer, a random-number generator, and a bit array).



3. `java.time`
The main API for dates, times, instants, and durations. JDK 1.8



<a name="7-%E5%88%86%E6%9E%90-object-methods"></a>
## 7. 分析 Object methods

<a name="71-equals"></a>
### 7.1 equals()
[The Java Language Specification](http://docs.oracle.com/javase/specs/) 要求: 
- 自反性, 对于任意非空引用 x, x.equals(x) 返回 true; 
- 对称性, 对于任意非空引用 x, y, x.equals(y) 与 y.equals(x) 应该相等;
- 传递性, 对于任意非空引用 x, y, z, x.equals(y) 为 true, y.equals(z) 为 true, 则 x.equals(z) 也为 true;
- 一致性, 对于任意非空引用 x, y, 如果 x, y 没有改变, 则 x.equals(y) 也不会变;
- 对于任意非空引用 x, x.equals(null) 返回 false;

采用 getClass(), instanceof 的标准:  
1. 如果子类拥有自己相等的概念, 则根据对称性要求, 应该强制使用 getClass();
2. 如果由父类决定相等的概念, 那么应该使用 instanceof, 这样不同的子类对象就可以进行比较;

<a name="72-hash-value-hash-table-%E5%92%8C-hashcode"></a>
### 7.2 hash value, hash table 和 hashCode()

如果 Employee.equals() 比较的是 emp 的 ID, 则 hashCode() 方法就需要散列 ID, 而不是 name, salary.



<a name="73-tostring"></a>
### 7.3 toString()

用于日志: 

```java
@Override 
public String toString() {
    return this.getClass().getName() + "[field1=" + this.field + "..." + "]";
}
```


<a name="8-reflection"></a>
## 8. Reflection



<a name="9-proxy"></a>
## 9. Proxy





